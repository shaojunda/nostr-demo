<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Demo - çœŸå®åŠ å¯†ç‰ˆæœ¬</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 0;
            text-align: center;
            margin-bottom: 30px;
            border-radius: 8px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .section {
            background: white;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e1e1;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 120px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            padding: 12px;
            margin: 10px 0;
            border-radius: 6px;
            font-weight: 500;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #b8daff;
        }

        .user-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .user-info strong {
            color: #667eea;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e1e1e1;
        }

        .tab {
            background: none;
            border: none;
            padding: 15px 20px;
            cursor: pointer;
            font-size: 16px;
            color: #666;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }

        .tab:hover {
            color: #667eea;
            background: #f8f9fa;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .article-item {
            border: 1px solid #e1e1e1;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 15px;
            background: #fafafa;
        }

        .article-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .article-content {
            color: #666;
            margin-bottom: 15px;
            line-height: 1.7;
        }

        .article-meta {
            font-size: 0.9em;
            color: #999;
            margin-bottom: 15px;
        }

        .article-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .article-actions button {
            background: #6c757d;
            padding: 8px 16px;
            font-size: 14px;
        }

        .article-actions button.active {
            background: #667eea;
        }

        .relay-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border: 1px solid #e1e1e1;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .relay-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .relay-status.connected {
            background: #28a745;
        }

        .relay-status.disconnected {
            background: #dc3545;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .version-info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }

        .version-info h3 {
            color: #007bff;
            margin-bottom: 10px;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

                .warning strong {
            color: #d63384;
        }

        .format-btn {
            background: #6c757d;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 5px;
        }

        .format-btn.active {
            background: #667eea;
            font-weight: 600;
        }

        .format-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .copy-success {
            background: #d4edda !important;
            color: #155724 !important;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2em;
            }

            .section {
                padding: 20px;
            }

            .article-actions {
                flex-direction: column;
            }

            .article-actions button {
                width: 100%;
                margin-bottom: 10px;
            }
        }

        /* JSON æ¨¡æ€æ¡†æ ·å¼ */
        .json-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .json-modal-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 90%;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .json-modal-header {
            background: #667eea;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .json-modal-header h3 {
            margin: 0;
            font-size: 18px;
        }

        .json-modal-header .close-json-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .json-modal-body {
            padding: 20px;
        }

        .json-modal-footer {
            background: #f8f9fa;
            padding: 15px 20px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .json-modal-footer button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            color: white;
        }

        /* å¼€å‘è€…æ¨¡å¼æ ·å¼ */
        .dev-button {
            display: none;
        }

        .dev-mode .dev-button {
            display: inline-block;
        }

        .dev-mode #toggleDevMode {
            background: #28a745 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¥ Nostr Demo</h1>
            <p>å»ä¸­å¿ƒåŒ–ç¤¾äº¤åè®®æ¼”ç¤ºåº”ç”¨ - çœŸå®åŠ å¯†ç‰ˆæœ¬</p>
        </div>

        <div id="app">
            <div class="loading">æ­£åœ¨åŠ è½½ nostr-tools åº“...</div>
        </div>

        <div id="status-message" class="status"></div>
    </div>

    <!-- é€šè¿‡ CDN åŠ è½½ nostr-tools -->
    <script src="https://unpkg.com/nostr-tools@2.7.0/lib/nostr.bundle.js"></script>

    <script>
        // ç­‰å¾… nostr-tools åŠ è½½å®Œæˆ
        document.addEventListener('DOMContentLoaded', function() {
            // æ£€æŸ¥ nostr-tools æ˜¯å¦åŠ è½½æˆåŠŸ
            if (typeof window.NostrTools === 'undefined') {
                document.getElementById('app').innerHTML = `
                    <div class="section">
                        <h2>âŒ åŠ è½½å¤±è´¥</h2>
                        <p>æ— æ³•åŠ è½½ nostr-tools åº“ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚</p>
                        <p>å¦‚æœé—®é¢˜æŒç»­å­˜åœ¨ï¼Œå¯ä»¥å°è¯•ä½¿ç”¨ npm ç‰ˆæœ¬ï¼š</p>
                        <pre style="background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto;">
npm install
npm run dev
                        </pre>
                    </div>
                `;
                return;
            }

            // ä»å…¨å±€å¯¹è±¡è·å– nostr-tools å‡½æ•°
            const {
                SimplePool,
                finalizeEvent,
                generateSecretKey,
                getPublicKey,
                nip19,
                validateEvent,
                verifyEvent
            } = window.NostrTools;

            // çœŸå®çš„ Nostr å®¢æˆ·ç«¯å®ç°
            class RealNostrClient {
            constructor() {
                    // é»˜è®¤ä¸­ç»§åˆ—è¡¨
                    this.defaultRelays = [
                    'wss://relay.damus.io',
                    'wss://nos.lol',
                    'wss://relay.snort.social',
                        'wss://relay.nostr.band',
                        'wss://nostr.wine',
                        'wss://relay.nostr.info',
                        'wss://nostr.internal.ikandev.xyz',
                    'wss://eden.nostr.land'
                ];

                    // æ¨èä¸­ç»§åˆ—è¡¨ï¼ˆç”¨äºå¿«é€Ÿæ·»åŠ ï¼‰
                    this.recommendedRelays = [
                        { url: 'wss://nostr.internal.ikandev.xyz', name: 'ikandev.xyz', description: 'å¿«é€Ÿå¯é çš„ä¸­ç»§' },
                        { url: 'wss://relay.damus.io', name: 'damus.io', description: 'Damus å®˜æ–¹ä¸­ç»§' },
                        { url: 'wss://relay.snort.social', name: 'snort.social', description: 'Snort å®˜æ–¹ä¸­ç»§' },
                        { url: 'wss://nos.lol', name: 'nos.lol', description: 'Nos å®˜æ–¹ä¸­ç»§' },
                        { url: 'wss://relay.nostr.band', name: 'nostr.band', description: 'Nostr.band ä¸­ç»§' },
                        { url: 'wss://eden.nostr.land', name: 'eden.nostr.land', description: 'Eden ä¸­ç»§' },
                        { url: 'wss://relay.nostr.info', name: 'nostr.info', description: 'Nostr.info ä¸­ç»§' },
                        { url: 'wss://nostr.wine', name: 'nostr.wine', description: 'Nostr.wine ä¸­ç»§' }
                    ];

                    // ä»æœ¬åœ°å­˜å‚¨åŠ è½½ä¸­ç»§åˆ—è¡¨ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤åˆ—è¡¨
                    this.relays = this.loadRelaysFromStorage();

                    this.pool = new SimplePool();
                this.privateKey = null;
                this.publicKey = null;
                    this.userMetadata = null;

                    // äº‹ä»¶ç§ç±»
                this.eventKinds = {
                    METADATA: 0,
                    TEXT_NOTE: 1,
                    CONTACT_LIST: 3,
                    REACTION: 7,
                    COMMENT: 1111,
                    LONG_FORM: 30023,
                        BOOKMARK: 10003,
                        BOOKMARK_SET: 30003
                    };

                    // è¿æ¥çŠ¶æ€
                    this.connectionStatus = new Map();

                    console.log('RealNostrClient initialized with nostr-tools');
                }

                // åˆ›å»ºæ–°è´¦å·
                async createAccount(name = '', about = '', picture = '', nip05 = '') {
                    try {
                        // ç”Ÿæˆç§é’¥ (è¿”å› Uint8Array)
                        const privateKey = generateSecretKey();

                        // ä»ç§é’¥æ´¾ç”Ÿå…¬é’¥ (éœ€è¦ Uint8Array æˆ– hex string)
                        const publicKey = getPublicKey(privateKey);

                        // ç”Ÿæˆç”¨æˆ·å‹å¥½çš„æ ¼å¼
                        const npub = nip19.npubEncode(publicKey);
                        const nsec = nip19.nsecEncode(privateKey);

                        // è®¾ç½®ç”¨æˆ·ä¿¡æ¯
                        await this.setUser(privateKey, publicKey);

                        // å‘å¸ƒç”¨æˆ·å…ƒæ•°æ®
                        if (name || about || picture || nip05) {
                            await this.publishUserMetadata(name, about, picture, nip05);
                        }

                        console.log('è´¦å·åˆ›å»ºæˆåŠŸ:', { npub, publicKey: publicKey.substring(0, 16) + '...' });

                        return {
                            privateKey,
                            publicKey,
                            npub,
                            nsec,
                            name,
                            about,
                            picture,
                            nip05
                        };

                    } catch (error) {
                        console.error('åˆ›å»ºè´¦å·å¤±è´¥:', error);
                        throw error;
                    }
                }

                // å¯¼å…¥è´¦å·
                async importAccount(nsec) {
                    try {
                        const decoded = nip19.decode(nsec);

                        if (decoded.type !== 'nsec') {
                            throw new Error('æ— æ•ˆçš„ nsec æ ¼å¼');
                        }

                        const privateKey = decoded.data; // è¿™å·²ç»æ˜¯ Uint8Array
                        const publicKey = getPublicKey(privateKey);
                        const npub = nip19.npubEncode(publicKey);

                        await this.setUser(privateKey, publicKey);

                        // è·å–ç”¨æˆ·å…ƒæ•°æ®
                        const metadata = await this.getUserMetadata(publicKey);

                        console.log('è´¦å·å¯¼å…¥æˆåŠŸ:', { npub, publicKey: publicKey.substring(0, 16) + '...' });

                        return {
                            privateKey,
                            publicKey,
                            npub,
                            nsec,
                            name: metadata?.name || '',
                            about: metadata?.about || '',
                            picture: metadata?.picture || '',
                            nip05: metadata?.nip05 || ''
                        };

                    } catch (error) {
                        console.error('å¯¼å…¥è´¦å·å¤±è´¥:', error);
                        throw error;
                    }
                }

                // è®¾ç½®ç”¨æˆ·
                async setUser(privateKey, publicKey) {
                this.privateKey = privateKey;
                this.publicKey = publicKey;

                    // éªŒè¯å¯†é’¥å¯¹ (ç¡®ä¿ä¸¤ä¸ªå¯†é’¥éƒ½æ˜¯æ­£ç¡®çš„æ ¼å¼)
                    const derivedPublicKey = getPublicKey(privateKey);
                    if (derivedPublicKey !== publicKey) {
                        throw new Error('ç§é’¥å’Œå…¬é’¥ä¸åŒ¹é…');
                    }

                    console.log('ç”¨æˆ·è®¾ç½®æˆåŠŸ');
                }

                // åˆå§‹åŒ–ä¸­ç»§è¿æ¥
                async initializeRelays() {
                    console.log('æ­£åœ¨åˆå§‹åŒ–ä¸­ç»§è¿æ¥...');

                    const connectionPromises = this.relays.map(async (relay) => {
                        try {
                            await this.testRelayConnection(relay);
                            this.connectionStatus.set(relay, 'connected');
                            console.log(`âœ… ä¸­ç»§è¿æ¥æˆåŠŸ: ${relay}`);
                        } catch (error) {
                            this.connectionStatus.set(relay, 'failed');
                            console.error(`âŒ ä¸­ç»§è¿æ¥å¤±è´¥: ${relay}`, error.message);
                        }
                    });

                    await Promise.allSettled(connectionPromises);

                    const connectedCount = Array.from(this.connectionStatus.values()).filter(status => status === 'connected').length;
                    console.log(`ä¸­ç»§åˆå§‹åŒ–å®Œæˆ: ${connectedCount}/${this.relays.length} ä¸ªä¸­ç»§è¿æ¥æˆåŠŸ`);
                }

                // æµ‹è¯•ä¸­ç»§è¿æ¥
                async testRelayConnection(relayUrl) {
                return new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('è¿æ¥è¶…æ—¶'));
                        }, 5000);

                        try {
                            console.log(`å°è¯•è¿æ¥åˆ°ä¸­ç»§: ${relayUrl}`);
                    const ws = new WebSocket(relayUrl);

                    ws.onopen = () => {
                                console.log(`ä¸­ç»§è¿æ¥æˆåŠŸ: ${relayUrl}`);
                                clearTimeout(timeout);
                                ws.close();
                                resolve();
                    };

                    ws.onerror = (error) => {
                                console.log(`ä¸­ç»§è¿æ¥å¤±è´¥: ${relayUrl}`, error);
                                clearTimeout(timeout);
                        reject(error);
                    };

                        } catch (error) {
                            console.log(`ä¸­ç»§è¿æ¥å¼‚å¸¸: ${relayUrl}`, error);
                            clearTimeout(timeout);
                            reject(error);
                        }
                    });
                }

                // åˆ›å»ºå¹¶ç­¾åäº‹ä»¶
            createEvent(kind, content, tags = []) {
                    if (!this.privateKey || !this.publicKey) {
                        throw new Error('ç”¨æˆ·æœªè®¾ç½®ï¼Œæ— æ³•åˆ›å»ºäº‹ä»¶');
                    }

                const event = {
                    kind,
                    content,
                    tags,
                    created_at: Math.floor(Date.now() / 1000),
                    pubkey: this.publicKey
                };

                    // ä½¿ç”¨ finalizeEvent å®Œæˆäº‹ä»¶ç­¾å
                    const signedEvent = finalizeEvent(event, this.privateKey);

                    // éªŒè¯äº‹ä»¶
                    const isValid = validateEvent(signedEvent);
                    if (!isValid) {
                        throw new Error('äº‹ä»¶éªŒè¯å¤±è´¥');
                    }

                    const isSignatureValid = verifyEvent(signedEvent);
                    if (!isSignatureValid) {
                        throw new Error('äº‹ä»¶ç­¾åéªŒè¯å¤±è´¥');
                    }

                    console.log('äº‹ä»¶åˆ›å»ºæˆåŠŸ:', { kind, id: signedEvent.id.substring(0, 16) + '...' });
                    return signedEvent;
                }

                                                // å‘å¸ƒäº‹ä»¶ - ä½¿ç”¨æ›´å¥å£®çš„æ–¹æ³•
            async publishEvent(event) {
                    if (!event.id || !event.sig) {
                        throw new Error('äº‹ä»¶æœªæ­£ç¡®ç­¾å');
                    }

                    console.log('æ­£åœ¨å‘å¸ƒäº‹ä»¶:', {
                        kind: event.kind,
                        id: event.id.substring(0, 16) + '...',
                        relays: this.relays.length
                    });

                    const results = [];
                    let successCount = 0;

                    // é€ä¸ªå°è¯•å‘å¸ƒåˆ°æ¯ä¸ªä¸­ç»§
                    for (const relay of this.relays) {
                        try {
                            console.log(`æ­£åœ¨å‘å¸ƒåˆ°ä¸­ç»§: ${relay}`);

                            await this.pool.publish([relay], event);

                            console.log(`âœ… æˆåŠŸå‘å¸ƒåˆ°ä¸­ç»§: ${relay}`);
                            results.push({ relay, success: true });
                            successCount++;

                                } catch (error) {
                            console.warn(`âŒ å‘å¸ƒåˆ°ä¸­ç»§ ${relay} å¤±è´¥:`, error.message);
                            results.push({ relay, success: false, error: error.message });
                            // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªä¸­ç»§
                        }
                    }

                    console.log(`å‘å¸ƒå®Œæˆ: ${successCount}/${this.relays.length} ä¸ªä¸­ç»§æˆåŠŸ`);

                    if (successCount > 0) {
                        return { event, success: true, relayCount: successCount, results };
                    } else {
                        return { event, success: false, error: 'æ‰€æœ‰ä¸­ç»§éƒ½å‘å¸ƒå¤±è´¥', results };
                    }
                }

                // å‘å¸ƒç”¨æˆ·å…ƒæ•°æ®
                async publishUserMetadata(name, about, picture = '', nip05 = '', website = '') {
                    const metadata = {
                        name: name || '',
                        about: about || '',
                        picture: picture || '',
                        nip05: nip05 || '',
                        website: website || ''
                    };

                    const event = this.createEvent(
                        this.eventKinds.METADATA,
                        JSON.stringify(metadata)
                    );

                    return await this.publishEvent(event);
                }

                // è·å–ç”¨æˆ·å…ƒæ•°æ®
                async getUserMetadata(pubkey) {
                    try {
                        const events = await this.pool.querySync(this.relays, [
                            {
                                kinds: [this.eventKinds.METADATA],
                                authors: [pubkey],
                                limit: 1
                            }
                        ]);

                        if (events.length > 0) {
                            const metadata = JSON.parse(events[0].content);
                            return metadata;
                        }

                        return null;
                    } catch (error) {
                        console.error('è·å–ç”¨æˆ·å…ƒæ•°æ®å¤±è´¥:', error);
                        return null;
                    }
                }

                // å‘å¸ƒæ–‡ç« 
                async publishArticle(title, content, summary = '') {
                const dTag = 'article_' + Date.now();
                const event = this.createEvent(
                    this.eventKinds.LONG_FORM,
                    content,
                    [
                        ['d', dTag],
                        ['title', title],
                            ['summary', summary],
                        ['published_at', Math.floor(Date.now() / 1000).toString()]
                    ]
                );

                return await this.publishEvent(event);
            }

                // ç‚¹èµæ–‡ç« 
            async likeArticle(articleId, authorPubkey) {
                const event = this.createEvent(
                    this.eventKinds.REACTION,
                    '+',
                    [
                        ['e', articleId],
                        ['p', authorPubkey]
                    ]
                );

                return await this.publishEvent(event);
            }

                // æ”¶è—æ–‡ç« 
            async bookmarkArticle(articleId, title = '') {
                const event = this.createEvent(
                    this.eventKinds.BOOKMARK,
                    '',
                    [
                        ['e', articleId],
                        ['title', title || 'æˆ‘çš„æ”¶è—']
                    ]
                );

                return await this.publishEvent(event);
            }

                // å…³æ³¨ä½œè€…
            async followAuthor(authorPubkey, alias = '') {
                const event = this.createEvent(
                    this.eventKinds.CONTACT_LIST,
                    '',
                    [['p', authorPubkey, '', alias]]
                );

                return await this.publishEvent(event);
            }

                // è¯„è®ºæ–‡ç« 
            async commentOnArticle(articleId, authorPubkey, content) {
                const articleATag = `30023:${authorPubkey}:${articleId}`;
                const event = this.createEvent(
                    this.eventKinds.COMMENT,
                    content,
                    [
                        ['A', articleATag],
                        ['K', '30023'],
                        ['P', authorPubkey]
                    ]
                );

                return await this.publishEvent(event);
            }

                                                                // è·å–æ—¶é—´çº¿ - ä½¿ç”¨æ›´å¥å£®çš„æ–¹æ³•
                async getTimeline(limit = 20) {
                    try {
                        console.log(`å¼€å§‹ä» ${this.relays.length} ä¸ªä¸­ç»§è·å–æ—¶é—´çº¿æ•°æ®...`);

                        const allEvents = [];
                        const relayResults = new Map();

                        // é€ä¸ªå°è¯•ä¸­ç»§ï¼Œå³ä½¿æŸä¸ªå¤±è´¥ä¹Ÿç»§ç»­å°è¯•å…¶ä»–
                        for (const relay of this.relays) {
                            try {
                                console.log(`æ­£åœ¨æŸ¥è¯¢ä¸­ç»§: ${relay}`);

                                console.log(`ğŸ” æ­£åœ¨æŸ¥è¯¢ä¸­ç»§ ${relay}ï¼ŒæŸ¥è¯¢æ¡ä»¶:`, {
                                    kinds: [this.eventKinds.TEXT_NOTE, this.eventKinds.LONG_FORM, this.eventKinds.COMMENT],
                                    limit: limit * 2,
                                    timeout: 8000
                                });

                                const events = await this.pool.querySync([relay], {
                                    kinds: [this.eventKinds.TEXT_NOTE, this.eventKinds.LONG_FORM, this.eventKinds.COMMENT],
                                    limit: limit * 2
                                }, {
                                    timeout: 8000 // æ¯ä¸ªä¸­ç»§8ç§’è¶…æ—¶
                                });

                                console.log(`âœ… ä¸­ç»§ ${relay} è¿”å› ${events.length} ä¸ªäº‹ä»¶`);
                                relayResults.set(relay, { success: true, count: events.length });
                                allEvents.push(...events);

                            } catch (error) {
                                console.warn(`âŒ ä¸­ç»§ ${relay} æŸ¥è¯¢å¤±è´¥:`, error.message);
                                relayResults.set(relay, { success: false, error: error.message });
                                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªä¸­ç»§ï¼Œä¸æŠ›å‡ºå¼‚å¸¸
                            }
                        }

                        // ç»Ÿè®¡ç»“æœ
                        const successfulRelays = Array.from(relayResults.values()).filter(r => r.success).length;
                        console.log(`æˆåŠŸæŸ¥è¯¢ ${successfulRelays}/${this.relays.length} ä¸ªä¸­ç»§ï¼Œæ€»å…±è·å– ${allEvents.length} ä¸ªäº‹ä»¶`);

                        if (allEvents.length === 0) {
                            console.warn('æ‰€æœ‰ä¸­ç»§éƒ½æŸ¥è¯¢å¤±è´¥ï¼Œè¿”å›ç©ºç»“æœ');
                            return [];
                        }

                        // å»é‡å¹¶æ’åº
                        const uniqueEvents = this.removeDuplicateEvents(allEvents);
                        const sortedEvents = uniqueEvents.sort((a, b) => b.created_at - a.created_at);

                        console.log(`å»é‡åå‰©ä½™ ${sortedEvents.length} ä¸ªäº‹ä»¶`);

                        // è¿”å›å‰ limit ä¸ªäº‹ä»¶
                        return sortedEvents.slice(0, limit);

                    } catch (error) {
                        console.error('è·å–æ—¶é—´çº¿è¿‡ç¨‹ä¸­å‘ç”Ÿæ„å¤–é”™è¯¯:', error);
                        return [];
                    }
                }

                                // è·å–ç‰¹å®šç”¨æˆ·çš„æ—¶é—´çº¿
                async getUserTimeline(pubkey, limit = 20) {
                    try {
                        console.log(`è·å–ç”¨æˆ· ${pubkey.substring(0, 16)}... çš„æ—¶é—´çº¿`);

                        const allEvents = [];

                        // é€ä¸ªå°è¯•ä¸­ç»§
                        for (const relay of this.relays) {
                            try {
                                console.log(`æ­£åœ¨ä» ${relay} æŸ¥è¯¢ç”¨æˆ·äº‹ä»¶`);

                                const events = await this.pool.querySync([relay], {
                                    kinds: [this.eventKinds.TEXT_NOTE, this.eventKinds.LONG_FORM, this.eventKinds.COMMENT],
                                    authors: [pubkey],
                                    limit: limit
                                }, {
                                    timeout: 8000
                                });

                                console.log(`âœ… ä¸­ç»§ ${relay} è¿”å› ${events.length} ä¸ªç”¨æˆ·äº‹ä»¶`);
                                if (events.length > 0) {
                                    console.log(`ğŸ“ äº‹ä»¶è¯¦æƒ…:`, events.map(e => ({
                                        id: e.id.substring(0, 16) + '...',
                                        kind: e.kind,
                                        created_at: e.created_at,
                                        content_preview: e.content.substring(0, 50) + '...'
                                    })));
                                }
                                allEvents.push(...events);

                            } catch (error) {
                                console.warn(`âŒ ä¸­ç»§ ${relay} æŸ¥è¯¢ç”¨æˆ·äº‹ä»¶å¤±è´¥:`, error.message);
                                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªä¸­ç»§
                            }
                        }

                        console.log(`æ€»å…±è·å–åˆ°ç”¨æˆ· ${allEvents.length} ä¸ªäº‹ä»¶`);

                        // å»é‡å¹¶æ’åº
                        const uniqueEvents = this.removeDuplicateEvents(allEvents);
                        return uniqueEvents.sort((a, b) => b.created_at - a.created_at);

                    } catch (error) {
                        console.error('è·å–ç”¨æˆ·æ—¶é—´çº¿å¤±è´¥:', error);
                        return [];
                    }
                }

                                // è·å–å…³æ³¨ç”¨æˆ·çš„æ—¶é—´çº¿
                async getFollowedTimeline(limit = 20) {
                    try {
                        if (!this.publicKey) {
                            throw new Error('ç”¨æˆ·æœªç™»å½•');
                        }

                        console.log(`è·å–å…³æ³¨ç”¨æˆ·çš„æ—¶é—´çº¿`);

                        // é¦–å…ˆè·å–å…³æ³¨åˆ—è¡¨ - é€ä¸ªå°è¯•ä¸­ç»§
                        let contactEvents = [];
                        for (const relay of this.relays) {
                            try {
                                console.log(`æ­£åœ¨ä» ${relay} è·å–å…³æ³¨åˆ—è¡¨`);

                                const events = await this.pool.querySync([relay], {
                                    kinds: [this.eventKinds.CONTACT_LIST],
                                    authors: [this.publicKey],
                                    limit: 1
                                }, {
                                    timeout: 8000
                                });

                                if (events.length > 0) {
                                    contactEvents = events;
                                    console.log(`âœ… ä» ${relay} è·å–åˆ°å…³æ³¨åˆ—è¡¨`);
                                    break; // æ‰¾åˆ°å…³æ³¨åˆ—è¡¨å°±åœæ­¢
                                }

                            } catch (error) {
                                console.warn(`âŒ ä» ${relay} è·å–å…³æ³¨åˆ—è¡¨å¤±è´¥:`, error.message);
                                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªä¸­ç»§
                            }
                        }

                        if (contactEvents.length === 0) {
                            console.log('æœªæ‰¾åˆ°å…³æ³¨åˆ—è¡¨');
                            return [];
                        }

                        // æå–å…³æ³¨çš„ç”¨æˆ·å…¬é’¥
                        const followedPubkeys = contactEvents[0].tags
                            .filter(tag => tag[0] === 'p')
                            .map(tag => tag[1]);

                        if (followedPubkeys.length === 0) {
                            console.log('å…³æ³¨åˆ—è¡¨ä¸ºç©º');
                            return [];
                        }

                        console.log(`æ‰¾åˆ° ${followedPubkeys.length} ä¸ªå…³æ³¨çš„ç”¨æˆ·`);

                        // è·å–å…³æ³¨ç”¨æˆ·çš„äº‹ä»¶ - é€ä¸ªå°è¯•ä¸­ç»§
                        const allEvents = [];
                        for (const relay of this.relays) {
                            try {
                                console.log(`æ­£åœ¨ä» ${relay} è·å–å…³æ³¨ç”¨æˆ·äº‹ä»¶`);

                                const events = await this.pool.querySync([relay], {
                                    kinds: [this.eventKinds.TEXT_NOTE, this.eventKinds.LONG_FORM, this.eventKinds.COMMENT],
                                    authors: followedPubkeys,
                                    limit: limit * 2
                                }, {
                                    timeout: 10000
                                });

                                console.log(`âœ… ä¸­ç»§ ${relay} è¿”å› ${events.length} ä¸ªå…³æ³¨ç”¨æˆ·äº‹ä»¶`);
                                allEvents.push(...events);

                            } catch (error) {
                                console.warn(`âŒ ä¸­ç»§ ${relay} è·å–å…³æ³¨ç”¨æˆ·äº‹ä»¶å¤±è´¥:`, error.message);
                                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªä¸­ç»§
                            }
                        }

                        console.log(`æ€»å…±è·å–åˆ°å…³æ³¨ç”¨æˆ· ${allEvents.length} ä¸ªäº‹ä»¶`);

                        // å»é‡å¹¶æ’åº
                        const uniqueEvents = this.removeDuplicateEvents(allEvents);
                        return uniqueEvents.sort((a, b) => b.created_at - a.created_at).slice(0, limit);

                    } catch (error) {
                        console.error('è·å–å…³æ³¨æ—¶é—´çº¿å¤±è´¥:', error);
                        return [];
                    }
                }

                // å»é™¤é‡å¤äº‹ä»¶
                removeDuplicateEvents(events) {
                    const seen = new Set();
                    return events.filter(event => {
                        if (seen.has(event.id)) {
                            return false;
                        }
                        seen.add(event.id);
                        return true;
                    });
                }

                                                // æµ‹è¯•ç‰¹å®šå…¬é’¥çš„äº‹ä»¶
                async testSpecificPubkey(pubkey) {
                    console.log(`ğŸ” æµ‹è¯•å…¬é’¥ ${pubkey.substring(0, 16)}... çš„äº‹ä»¶`);

                    for (const relay of this.relays) {
                        try {
                            console.log(`æ­£åœ¨ä» ${relay} æŸ¥è¯¢å…¬é’¥äº‹ä»¶...`);

                            // æŸ¥è¯¢æ‰€æœ‰ç±»å‹çš„äº‹ä»¶
                            const events = await this.pool.querySync([relay], [
                                {
                                    authors: [pubkey],
                                    limit: 50
                                }
                            ], {
                                timeout: 8000
                            });

                            console.log(`âœ… ä¸­ç»§ ${relay} è¿”å› ${events.length} ä¸ªäº‹ä»¶`);
                            if (events.length > 0) {
                                console.log(`ğŸ“ æ‰¾åˆ°çš„äº‹ä»¶:`, events.map(e => ({
                                    id: e.id.substring(0, 16) + '...',
                                    kind: e.kind,
                                    created_at: e.created_at,
                                    content_preview: e.content.substring(0, 100) + '...'
                                })));
                            }

                        } catch (error) {
                            console.warn(`âŒ ä¸­ç»§ ${relay} æŸ¥è¯¢å¤±è´¥:`, error.message);
                        }
                    }
                }

                                // æµ‹è¯•ç‰¹å®šå…¬é’¥çš„ 30023 äº‹ä»¶
                async testSpecificPubkey30023(pubkey) {
                    console.log(`ğŸ” ä¸“é—¨æµ‹è¯•å…¬é’¥ ${pubkey.substring(0, 16)}... çš„ 30023 äº‹ä»¶`);

                    for (const relay of this.relays) {
                        try {
                            console.log(`æ­£åœ¨ä» ${relay} æŸ¥è¯¢å…¬é’¥çš„ 30023 äº‹ä»¶...`);

                            // ä¸“é—¨æŸ¥è¯¢ 30023 ç±»å‹çš„äº‹ä»¶
                            const events = await this.pool.querySync([relay], {
                                kinds: [30023],
                                authors: [pubkey],
                                limit: 50
                            }, {
                                timeout: 8000
                            });

                            console.log(`âœ… ä¸­ç»§ ${relay} è¿”å› ${events.length} ä¸ª 30023 äº‹ä»¶`);
                            if (events.length > 0) {
                                console.log(`ğŸ“ æ‰¾åˆ°çš„ 30023 äº‹ä»¶:`, events.map(e => ({
                                    id: e.id.substring(0, 16) + '...',
                                    kind: e.kind,
                                    created_at: e.created_at,
                                    content_preview: e.content.substring(0, 100) + '...'
                                })));
                            }

                        } catch (error) {
                            console.warn(`âŒ ä¸­ç»§ ${relay} æŸ¥è¯¢ 30023 äº‹ä»¶å¤±è´¥:`, error.message);
                        }
                    }
                }

                // æ ¹æ®äº‹ä»¶ ID æŸ¥è¯¢äº‹ä»¶
                async queryEventById(eventId) {
                    console.log(`ğŸ” æ ¹æ®äº‹ä»¶ ID æŸ¥è¯¢: ${eventId.substring(0, 16)}...`);

                    const results = [];

                    for (const relay of this.relays) {
                        try {
                            console.log(`æ­£åœ¨ä» ${relay} æŸ¥è¯¢äº‹ä»¶...`);

                            const event = this.pool.get([relay], [
                                {
                                    ids: [eventId]
                                }
                            ], {
                                timeout: 8000
                            });

                            if (event) {
  console.log('it exists indeed on this relay:', event)
}

                            const events = await this.pool.querySync([relay], {
                                ids: [eventId]
                            }, {
                                timeout: 8000
                            });

                            console.log(`âœ… ä¸­ç»§ ${relay} è¿”å› ${events.length} ä¸ªäº‹ä»¶`);
                            if (events.length > 0) {
                                const event = events[0];
                                console.log(`ğŸ“ æ‰¾åˆ°äº‹ä»¶:`, {
                                    id: event.id,
                                    pubkey: event.pubkey.substring(0, 16) + '...',
                                    kind: event.kind,
                                    created_at: event.created_at,
                                    content: event.content.substring(0, 200) + '...',
                                    tags: event.tags
                                });

                                results.push({
                                    relay,
                                    success: true,
                                    event: event
                                });
                            } else {
                                results.push({
                                    relay,
                                    success: false,
                                    message: 'æœªæ‰¾åˆ°äº‹ä»¶'
                                });
                            }

                        } catch (error) {
                            console.warn(`âŒ ä¸­ç»§ ${relay} æŸ¥è¯¢å¤±è´¥:`, error.message);
                            results.push({
                                relay,
                                success: false,
                                error: error.message
                            });
                        }
                    }

                    const successfulRelays = results.filter(r => r.success).length;
                    console.log(`âœ… æŸ¥è¯¢å®Œæˆ: ${successfulRelays}/${this.relays.length} ä¸ªä¸­ç»§æˆåŠŸ`);

                    return results;
                }

                                // æµ‹è¯•ç‰¹å®šä¸­ç»§çš„è¿æ¥å’ŒæŸ¥è¯¢
                async testSpecificRelay(relayUrl) {
                    console.log(`ğŸ” æµ‹è¯•ä¸­ç»§ ${relayUrl}`);

                    try {
                        // æµ‹è¯•è¿æ¥
                        console.log(`1. æµ‹è¯•è¿æ¥...`);
                        await this.testRelayConnection(relayUrl);
                        console.log(`âœ… è¿æ¥æˆåŠŸ`);

                        // æµ‹è¯•æŸ¥è¯¢
                        console.log(`2. æµ‹è¯•æŸ¥è¯¢...`);
                        const events = await this.pool.querySync([relayUrl], {
                            kinds: [this.eventKinds.LONG_FORM],
                            limit: 10
                        }, {
                            timeout: 10000
                        });

                        console.log(`âœ… æŸ¥è¯¢æˆåŠŸï¼Œè¿”å› ${events.length} ä¸ªäº‹ä»¶`);
                        if (events.length > 0) {
                            console.log(`ğŸ“ äº‹ä»¶ç¤ºä¾‹:`, events[0]);
                        }

                    } catch (error) {
                        console.error(`âŒ æµ‹è¯•å¤±è´¥:`, error.message);
                    }
                }

                                // æµ‹è¯•ç‰¹å®šä¸­ç»§çš„ç‰¹å®šå…¬é’¥æŸ¥è¯¢
                async testSpecificRelayForPubkey(relayUrl, pubkey) {
                    console.log(`ğŸ” æµ‹è¯•ä¸­ç»§ ${relayUrl} å¯¹å…¬é’¥ ${pubkey.substring(0, 16)}... çš„æŸ¥è¯¢`);

                    try {
                        // æµ‹è¯•è¿æ¥
                        console.log(`1. æµ‹è¯•è¿æ¥...`);
                        await this.testRelayConnection(relayUrl);
                        console.log(`âœ… è¿æ¥æˆåŠŸ`);

                        // æµ‹è¯•æŸ¥è¯¢æ‰€æœ‰ç±»å‹äº‹ä»¶
                        console.log(`2. æµ‹è¯•æŸ¥è¯¢æ‰€æœ‰ç±»å‹äº‹ä»¶...`);
                        const allEvents = await this.pool.querySync([relayUrl], [
                            {
                                authors: [pubkey],
                                limit: 50
                            }
                        ], {
                            timeout: 10000
                        });

                        console.log(`âœ… æŸ¥è¯¢æ‰€æœ‰ç±»å‹äº‹ä»¶æˆåŠŸï¼Œè¿”å› ${allEvents.length} ä¸ªäº‹ä»¶`);
                        if (allEvents.length > 0) {
                            console.log(`ğŸ“ æ‰€æœ‰äº‹ä»¶:`, allEvents.map(e => ({
                                id: e.id.substring(0, 16) + '...',
                                kind: e.kind,
                                created_at: e.created_at,
                                content_preview: e.content.substring(0, 50) + '...'
                            })));
                        }

                        // æµ‹è¯•æŸ¥è¯¢ 30023 ç±»å‹äº‹ä»¶
                        console.log(`3. æµ‹è¯•æŸ¥è¯¢ 30023 ç±»å‹äº‹ä»¶...`);
                        const events30023 = await this.pool.querySync([relayUrl], [
                            {
                                kinds: [30023],
                                authors: [pubkey],
                                limit: 50
                            }
                        ], {
                            timeout: 10000
                        });

                        console.log(`âœ… æŸ¥è¯¢ 30023 ç±»å‹äº‹ä»¶æˆåŠŸï¼Œè¿”å› ${events30023.length} ä¸ªäº‹ä»¶`);
                        if (events30023.length > 0) {
                            console.log(`ğŸ“ 30023 äº‹ä»¶:`, events30023.map(e => ({
                                id: e.id.substring(0, 16) + '...',
                                kind: e.kind,
                                created_at: e.created_at,
                                content_preview: e.content.substring(0, 50) + '...'
                            })));
                        }

                    } catch (error) {
                        console.error(`âŒ æµ‹è¯•å¤±è´¥:`, error.message);
                    }
                }

                                // æµ‹è¯•æ—¶é—´çº¿æŸ¥è¯¢é€»è¾‘
                async testTimelineQueryLogic(relayUrl) {
                    console.log(`ğŸ” æµ‹è¯•æ—¶é—´çº¿æŸ¥è¯¢é€»è¾‘ - ä¸­ç»§: ${relayUrl}`);

                    try {
                        // 1. æµ‹è¯•æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·çš„ 30023 äº‹ä»¶ï¼ˆæ—¶é—´çº¿æŸ¥è¯¢ï¼‰
                        console.log(`1. æµ‹è¯•æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·çš„ 30023 äº‹ä»¶...`);
                        const allEvents = await this.pool.querySync([relayUrl], [
                            {
                                kinds: [30023],
                                limit: 50
                            }
                        ], {
                            timeout: 10000
                        });

                        console.log(`âœ… æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·äº‹ä»¶æˆåŠŸï¼Œè¿”å› ${allEvents.length} ä¸ªäº‹ä»¶`);
                        if (allEvents.length > 0) {
                            console.log(`ğŸ“ æ‰€æœ‰ç”¨æˆ·äº‹ä»¶:`, allEvents.map(e => ({
                                id: e.id.substring(0, 16) + '...',
                                pubkey: e.pubkey.substring(0, 16) + '...',
                                kind: e.kind,
                                created_at: e.created_at,
                                content_preview: e.content.substring(0, 50) + '...'
                            })));
                        }

                        // 2. æ£€æŸ¥æ˜¯å¦åŒ…å«ç‰¹å®šå…¬é’¥çš„äº‹ä»¶
                        const targetPubkey = '98496f39197bb0da9b8d647560e3d1a96513a3642a3653836543525a56b8f2b8';
                        const targetEvents = allEvents.filter(e => e.pubkey === targetPubkey);

                        console.log(`2. æ£€æŸ¥æ˜¯å¦åŒ…å«ç›®æ ‡å…¬é’¥çš„äº‹ä»¶...`);
                        console.log(`ç›®æ ‡å…¬é’¥: ${targetPubkey.substring(0, 16)}...`);
                        console.log(`åœ¨ ${allEvents.length} ä¸ªäº‹ä»¶ä¸­æ‰¾åˆ° ${targetEvents.length} ä¸ªç›®æ ‡å…¬é’¥äº‹ä»¶`);

                        if (targetEvents.length > 0) {
                            console.log(`ğŸ“ ç›®æ ‡å…¬é’¥äº‹ä»¶:`, targetEvents.map(e => ({
                                id: e.id.substring(0, 16) + '...',
                                kind: e.kind,
                                created_at: e.created_at,
                                content_preview: e.content.substring(0, 50) + '...'
                            })));
                        } else {
                            console.log(`âŒ æœªæ‰¾åˆ°ç›®æ ‡å…¬é’¥çš„äº‹ä»¶`);
                        }

                        // 3. æµ‹è¯•æŸ¥è¯¢æ‰€æœ‰ç±»å‹çš„äº‹ä»¶
                        console.log(`3. æµ‹è¯•æŸ¥è¯¢æ‰€æœ‰ç±»å‹çš„äº‹ä»¶...`);
                        const allTypeEvents = await this.pool.querySync([relayUrl], [
                            {
                                limit: 50
                            }
                        ], {
                            timeout: 10000
                        });

                        console.log(`âœ… æŸ¥è¯¢æ‰€æœ‰ç±»å‹äº‹ä»¶æˆåŠŸï¼Œè¿”å› ${allTypeEvents.length} ä¸ªäº‹ä»¶`);
                        const targetAllTypeEvents = allTypeEvents.filter(e => e.pubkey === targetPubkey);
                        console.log(`åœ¨æ‰€æœ‰ç±»å‹äº‹ä»¶ä¸­æ‰¾åˆ° ${targetAllTypeEvents.length} ä¸ªç›®æ ‡å…¬é’¥äº‹ä»¶`);

                        if (targetAllTypeEvents.length > 0) {
                            console.log(`ğŸ“ ç›®æ ‡å…¬é’¥çš„æ‰€æœ‰ç±»å‹äº‹ä»¶:`, targetAllTypeEvents.map(e => ({
                                id: e.id.substring(0, 16) + '...',
                                kind: e.kind,
                                created_at: e.created_at,
                                content_preview: e.content.substring(0, 50) + '...'
                            })));
                        }

                        return {
                            totalEvents: allEvents.length,
                            targetEvents: targetEvents.length,
                            totalAllTypeEvents: allTypeEvents.length,
                            targetAllTypeEvents: targetAllTypeEvents.length,
                            targetPubkey: targetPubkey.substring(0, 16) + '...'
                        };

                    } catch (error) {
                        console.error(`âŒ æµ‹è¯•å¤±è´¥:`, error.message);
                        throw error;
                    }
                }

                // ä½¿ç”¨åŸç”Ÿ WebSocket æµ‹è¯•æŸ¥è¯¢
                async testWithRawWebSocket(relayUrl, pubkey) {
                    console.log(`ğŸ” ä½¿ç”¨åŸç”Ÿ WebSocket æµ‹è¯•ä¸­ç»§ ${relayUrl}`);

                    return new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('è¿æ¥è¶…æ—¶'));
                        }, 10000);

                        try {
                            const ws = new WebSocket(relayUrl);

                            ws.onopen = () => {
                                console.log(`âœ… WebSocket è¿æ¥æˆåŠŸ`);

                                // å‘é€ REQ æ¶ˆæ¯
                                const reqMessage = [
                                    "REQ",
                                    "test-subscription",
                                    {
                                        kinds: [30023],
                                        authors: [pubkey],
                                        limit: 50
                                    }
                                ];

                                console.log(`ğŸ“¤ å‘é€æŸ¥è¯¢æ¶ˆæ¯:`, reqMessage);
                                ws.send(JSON.stringify(reqMessage));

                                // è®¾ç½®æ¶ˆæ¯å¤„ç†
                                let eventCount = 0;
                                ws.onmessage = (event) => {
                                    try {
                                        const data = JSON.parse(event.data);
                                        console.log(`ğŸ“¥ æ”¶åˆ°æ¶ˆæ¯:`, data);

                                        if (data[0] === 'EVENT') {
                                            eventCount++;
                                            console.log(`ğŸ“ æ”¶åˆ°äº‹ä»¶ ${eventCount}:`, data[2]);
                                        } else if (data[0] === 'EOSE') {
                                            console.log(`âœ… æŸ¥è¯¢å®Œæˆï¼Œæ€»å…±æ”¶åˆ° ${eventCount} ä¸ªäº‹ä»¶`);
                                            clearTimeout(timeout);
                                            ws.close();
                                            resolve(eventCount);
                                        }
                                    } catch (error) {
                                        console.error(`âŒ è§£ææ¶ˆæ¯å¤±è´¥:`, error);
                                    }
                                };

                                ws.onerror = (error) => {
                                    console.error(`âŒ WebSocket é”™è¯¯:`, error);
                                    clearTimeout(timeout);
                                    reject(error);
                                };

                                ws.onclose = () => {
                                    console.log(`ğŸ”Œ WebSocket è¿æ¥å…³é—­`);
                                };

                            };

                            ws.onerror = (error) => {
                                console.error(`âŒ WebSocket è¿æ¥å¤±è´¥:`, error);
                                clearTimeout(timeout);
                                reject(error);
                            };

                        } catch (error) {
                            console.error(`âŒ WebSocket åˆ›å»ºå¤±è´¥:`, error);
                            clearTimeout(timeout);
                            reject(error);
                        }
                    });
                }



                // æ·»åŠ ä¸­ç»§
                async addRelay(relayUrl) {
                    if (this.relays.includes(relayUrl)) {
                    throw new Error('è¯¥ä¸­ç»§å·²å­˜åœ¨');
                }

                    await this.testRelayConnection(relayUrl);
                this.relays.push(relayUrl);
                    this.connectionStatus.set(relayUrl, 'connected');

                    console.log(`ä¸­ç»§æ·»åŠ æˆåŠŸ: ${relayUrl}`);
                }

                // è·å–ä¸­ç»§åˆ—è¡¨
                getRelays() {
                    return this.relays.map(url => ({
                        url,
                        connected: this.connectionStatus.get(url) === 'connected'
                    }));
                }

                // å·¥å…·æ–¹æ³•
            truncateKey(key, length = 16) {
                if (!key) return '';
                return key.length > length ? key.substring(0, length) + '...' : key;
            }

            formatTime(timestamp) {
                const date = new Date(timestamp * 1000);
                return date.toLocaleString('zh-CN');
            }

                getTagValue(tags, tagName) {
                    const tag = tags.find(t => t[0] === tagName);
                    return tag ? tag[1] : null;
                }

                destroy() {
                    this.pool.close(this.relays);
                }

                // ä¸­ç»§ç®¡ç†æ–¹æ³•
                loadRelaysFromStorage() {
                    try {
                        const savedRelays = localStorage.getItem('nostr-relays');
                        if (savedRelays) {
                            return JSON.parse(savedRelays);
                        }
                    } catch (error) {
                        console.error('åŠ è½½ä¸­ç»§åˆ—è¡¨å¤±è´¥:', error);
                    }
                    return [...this.defaultRelays]; // è¿”å›é»˜è®¤åˆ—è¡¨çš„å‰¯æœ¬
                }

                saveRelaysToStorage() {
                    try {
                        localStorage.setItem('nostr-relays', JSON.stringify(this.relays));
                        console.log('ä¸­ç»§åˆ—è¡¨å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
                    } catch (error) {
                        console.error('ä¿å­˜ä¸­ç»§åˆ—è¡¨å¤±è´¥:', error);
                    }
                }

                getRecommendedRelays() {
                    // è¿”å›å°šæœªæ·»åŠ çš„æ¨èä¸­ç»§
                    return this.recommendedRelays.filter(relay =>
                        !this.relays.includes(relay.url)
                    );
                }

                async addRelay(relayUrl) {
                    if (this.relays.includes(relayUrl)) {
                        throw new Error('è¯¥ä¸­ç»§å·²å­˜åœ¨');
                    }

                    await this.testRelayConnection(relayUrl);
                    this.relays.push(relayUrl);
                    this.connectionStatus.set(relayUrl, 'connected');
                    this.saveRelaysToStorage(); // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨

                    console.log(`ä¸­ç»§æ·»åŠ æˆåŠŸ: ${relayUrl}`);
                }

                removeRelay(relayUrl) {
                    const index = this.relays.indexOf(relayUrl);
                    if (index > -1) {
                        this.relays.splice(index, 1);
                        this.connectionStatus.delete(relayUrl);
                        this.saveRelaysToStorage(); // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
                        console.log(`ä¸­ç»§ç§»é™¤æˆåŠŸ: ${relayUrl}`);
                        return true;
                    }
                    return false;
            }
        }

        // åº”ç”¨ç±»
        class NostrApp {
            constructor() {
                    this.client = new RealNostrClient();
                this.currentSection = 'auth';
                this.currentTab = 'create';
                this.articles = [];
            }

            async init() {
                this.createUI();
                this.bindEvents();

                const savedUser = localStorage.getItem('nostr-user');
                if (savedUser) {
                    const user = JSON.parse(savedUser);
                        // æ³¨æ„ï¼šç§é’¥éœ€è¦ä» nsec é‡æ–°è§£ç 
                        if (user.nsec) {
                            try {
                                const decoded = nip19.decode(user.nsec);
                                this.client.privateKey = decoded.data;
                    this.client.publicKey = user.publicKey;
                    this.showUserInfo(user);
                    this.showSection('main');
                                // å»¶è¿Ÿæ›´æ–°å¯†é’¥æ˜¾ç¤ºï¼Œç¡®ä¿ DOM å·²åŠ è½½
                                setTimeout(() => {
                                    this.updateKeyDisplay();
                                }, 100);
                            } catch (error) {
                                console.error('æ¢å¤ç”¨æˆ·ä¼šè¯å¤±è´¥:', error);
                                localStorage.removeItem('nostr-user');
                            }
                        }
                }

                await this.client.initializeRelays();
                this.updateRelayList();
                    this.updateQuickAddRelays();
            }

            createUI() {
                const app = document.getElementById('app');
                app.innerHTML = `
                    <div id="auth-section" class="section" style="display: ${this.currentSection === 'auth' ? 'block' : 'none'};">
                        <h2>æ¬¢è¿ä½¿ç”¨ Nostr Demo</h2>

                        <div class="tabs">
                            <button class="tab active" data-tab="create">åˆ›å»ºè´¦å·</button>
                            <button class="tab" data-tab="import">å¯¼å…¥è´¦å·</button>
                        </div>

                        <div id="create-tab" class="tab-content active">
                            <div class="form-group">
                                <label for="userName">ç”¨æˆ·å:</label>
                                <input type="text" id="userName" placeholder="è¯·è¾“å…¥ç”¨æˆ·å">
                            </div>

                            <div class="form-group">
                                <label for="userAbout">ä¸ªäººç®€ä»‹:</label>
                                <textarea id="userAbout" placeholder="è¯·è¾“å…¥ä¸ªäººç®€ä»‹"></textarea>
                            </div>

                            <button id="createAccount">åˆ›å»ºè´¦å·</button>
                        </div>

                        <div id="import-tab" class="tab-content">
                            <div class="form-group">
                                <label for="nsecInput">ç§é’¥ (nsec):</label>
                                <input type="password" id="nsecInput" placeholder="è¯·è¾“å…¥ nsec ç§é’¥">
                            </div>

                            <button id="importAccount">å¯¼å…¥è´¦å·</button>
                        </div>
                    </div>

                    <div id="main-section" class="section" style="display: ${this.currentSection === 'main' ? 'block' : 'none'};">
                        <div id="user-info" class="user-info">
                            <strong>ç”¨æˆ·:</strong> <span id="user-name"></span>
                            (<span id="user-pubkey"></span>)
                            <br>
                            <strong>ç®€ä»‹:</strong> <span id="user-about"></span>
                        </div>

                        <div class="tabs">
                            <button class="tab active" data-tab="timeline">æ—¶é—´çº¿</button>
                            <button class="tab" data-tab="publish">å‘å¸ƒæ–‡ç« </button>
                                <button class="tab" data-tab="keys">å¯†é’¥ç®¡ç†</button>
                            <button class="tab" data-tab="relays">ä¸­ç»§ç®¡ç†</button>
                        </div>

                        <div id="timeline-tab" class="tab-content active">
                            <div style="margin-bottom: 20px;">
                                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                        <label style="margin-right: 10px; font-weight: 600;">æ—¶é—´çº¿ç±»å‹:</label>
                                        <select id="timelineType" style="padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                                            <option value="global">å…¨å±€æ—¶é—´çº¿</option>
                                            <option value="followed">å…³æ³¨ç”¨æˆ·</option>
                                            <option value="user">æˆ‘çš„æ–‡ç« </option>
                                        </select>
                                        <button id="refreshTimeline" style="margin-left: 10px;">åˆ·æ–°æ—¶é—´çº¿</button>
                                        <button id="debugRelays" class="dev-button" style="background: #6c757d; margin-left: 10px;">è°ƒè¯•ä¸­ç»§</button>
                    <button id="testSpecificPubkey" class="dev-button" style="background: #28a745; margin-left: 10px;">æµ‹è¯•ç‰¹å®šå…¬é’¥</button>
                    <button id="testSpecificRelay" class="dev-button" style="background: #ffc107; margin-left: 10px;">æµ‹è¯•ç‰¹å®šä¸­ç»§</button>
                    <button id="test30023Events" class="dev-button" style="background: #17a2b8; margin-left: 10px;">æµ‹è¯•30023äº‹ä»¶</button>
                    <button id="queryEventById" class="dev-button" style="background: #6f42c1; margin-left: 10px;">æ ¹æ®IDæŸ¥è¯¢</button>
                    <button id="testSpecificRelayForPubkey" class="dev-button" style="background: #6f42c1; margin-left: 10px;">æµ‹è¯•ç‰¹å®šä¸­ç»§å…¬é’¥</button>
                    <button id="testRawWebSocket" class="dev-button" style="background: #fd7e14; margin-left: 10px;">åŸç”ŸWebSocketæµ‹è¯•</button>
                    <button id="testTimelineLogic" class="dev-button" style="background: #20c997; margin-left: 10px;">æµ‹è¯•æ—¶é—´çº¿é€»è¾‘</button>
                    <button id="toggleDevMode" style="background: #6c757d; margin-left: 10px;">ğŸ”§ å¼€å‘è€…æ¨¡å¼</button>
                                    </div>
                            </div>

                            <div id="timeline-content">
                                <div class="loading">æ—¶é—´çº¿åŠŸèƒ½æ¼”ç¤ºä¸­...</div>
                            </div>
                        </div>

                        <div id="publish-tab" class="tab-content">
                            <div class="form-group">
                                <label for="articleTitle">æ–‡ç« æ ‡é¢˜:</label>
                                <input type="text" id="articleTitle" placeholder="è¯·è¾“å…¥æ–‡ç« æ ‡é¢˜">
                            </div>

                            <div class="form-group">
                                <label for="articleContent">æ–‡ç« å†…å®¹:</label>
                                <textarea id="articleContent" placeholder="è¯·è¾“å…¥æ–‡ç« å†…å®¹" rows="10"></textarea>
                            </div>

                            <button id="publishArticle">å‘å¸ƒæ–‡ç« </button>
                        </div>

                            <div id="keys-tab" class="tab-content">
                                <div class="form-group">
                                    <h3>ğŸ”‘ å…¬é’¥ä¿¡æ¯</h3>
                                    <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                                        <div style="margin-bottom: 15px;">
                                            <label style="font-weight: 600; color: #667eea;">æ ¼å¼é€‰æ‹©:</label>
                                            <div style="margin-top: 8px;">
                                                <button id="format-npub" class="format-btn active" data-format="npub">npub æ ¼å¼</button>
                                                <button id="format-hex" class="format-btn" data-format="hex">Hex æ ¼å¼</button>
                                            </div>
                                        </div>

                                        <div style="margin-bottom: 15px;">
                                            <label style="font-weight: 600; color: #667eea;">å…¬é’¥:</label>
                                            <div style="display: flex; align-items: center; margin-top: 8px;">
                                                <input type="text" id="public-key-display" readonly style="flex: 1; margin-right: 10px; font-family: monospace; font-size: 14px;">
                                                <button id="copy-public-key" style="background: #28a745; padding: 8px 16px; font-size: 14px;">
                                                    ğŸ“‹ å¤åˆ¶
                                                </button>
                                            </div>
                                        </div>

                                        <div style="margin-bottom: 15px;">
                                            <label style="font-weight: 600; color: #667eea;">ç§é’¥ (nsec):</label>
                                            <div style="display: flex; align-items: center; margin-top: 8px;">
                                                <input type="password" id="private-key-display" readonly style="flex: 1; margin-right: 10px; font-family: monospace; font-size: 14px;">
                                                <button id="copy-private-key" style="background: #dc3545; padding: 8px 16px; font-size: 14px;">
                                                    ğŸ“‹ å¤åˆ¶
                                                </button>
                                                <button id="toggle-private-key" style="background: #6c757d; padding: 8px 16px; font-size: 14px; margin-left: 5px;">
                                                    ğŸ‘ï¸ æ˜¾ç¤º
                                                </button>
                                            </div>
                                        </div>

                                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 10px; border-radius: 4px; font-size: 14px;">
                                            <strong>âš ï¸ å®‰å…¨æé†’:</strong>
                                            <ul style="margin: 10px 0 0 20px;">
                                                <li>è¯·å¦¥å–„ä¿ç®¡æ‚¨çš„ç§é’¥ï¼Œä¸è¦åˆ†äº«ç»™ä»»ä½•äºº</li>
                                                <li>ç§é’¥ä¸¢å¤±å°†æ— æ³•æ¢å¤æ‚¨çš„è´¦å·</li>
                                                <li>å»ºè®®å°†ç§é’¥å¤‡ä»½åˆ°å®‰å…¨çš„åœ°æ–¹</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                        </div>

                        <div id="relays-tab" class="tab-content">
                            <div class="form-group">
                                <label for="relayUrl">ä¸­ç»§åœ°å€:</label>
                                <input type="url" id="relayUrl" placeholder="wss://relay.example.com">
                            </div>

                            <button id="addRelay">æ·»åŠ ä¸­ç»§</button>

                                <div style="margin: 20px 0;">
                                    <h4>å¿«é€Ÿæ·»åŠ å¸¸ç”¨ä¸­ç»§:</h4>
                                    <div id="quick-add-relays"></div>
                                </div>

                            <div id="relay-list">
                                <h3>ä¸­ç»§åˆ—è¡¨</h3>
                                <div id="relay-items"></div>
                            </div>
                        </div>
                    </div>
                `;
            }

            bindEvents() {
                // æ ‡ç­¾åˆ‡æ¢
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('tab')) {
                        this.switchTab(e.target.dataset.tab);
                    }
                });

                // åˆ›å»ºè´¦å·
                document.getElementById('createAccount').addEventListener('click', async () => {
                    await this.handleCreateAccount();
                });

                // å¯¼å…¥è´¦å·
                document.getElementById('importAccount').addEventListener('click', async () => {
                    await this.handleImportAccount();
                });

                // å‘å¸ƒæ–‡ç« 
                document.getElementById('publishArticle').addEventListener('click', async () => {
                    await this.handlePublishArticle();
                });

                // åˆ·æ–°æ—¶é—´çº¿
                document.getElementById('refreshTimeline').addEventListener('click', async () => {
                    await this.handleRefreshTimeline();
                    });

                    // è°ƒè¯•ä¸­ç»§
                                    document.getElementById('debugRelays').addEventListener('click', async () => {
                    await this.handleDebugRelays();
                });

                document.getElementById('testSpecificPubkey').addEventListener('click', async () => {
                    const pubkey = prompt('è¯·è¾“å…¥è¦æµ‹è¯•çš„å…¬é’¥ (hex æ ¼å¼):', '98496f39197bb0da9b8d647560e3d1a96513a3642a3653836543525a56b8f2b8');
                    if (pubkey) {
                        await this.client.testSpecificPubkey(pubkey);
                    }
                });

                document.getElementById('testSpecificRelay').addEventListener('click', async () => {
                    const relayUrl = prompt('è¯·è¾“å…¥è¦æµ‹è¯•çš„ä¸­ç»§ URL:', 'wss://nostr.internal.ikandev.xyz');
                    if (relayUrl) {
                        await this.client.testSpecificRelay(relayUrl);
                    }
                });

                document.getElementById('test30023Events').addEventListener('click', async () => {
                    const pubkey = prompt('è¯·è¾“å…¥è¦æµ‹è¯•çš„å…¬é’¥ (hex æ ¼å¼):', '98496f39197bb0da9b8d647560e3d1a96513a3642a3653836543525a56b8f2b8');
                    if (pubkey) {
                        await this.client.testSpecificPubkey30023(pubkey);
                    }
                });

                document.getElementById('queryEventById').addEventListener('click', async () => {
                    const eventId = prompt('è¯·è¾“å…¥è¦æŸ¥è¯¢çš„äº‹ä»¶ ID (hex æ ¼å¼):', '5a30e25ce5618461faca1408cb81699896b271d7ec27c128e53056921e5f3df7');
                    if (eventId) {
                        try {
                            const results = await this.client.queryEventById(eventId);
                            console.log(`âœ… æ ¹æ® ID æŸ¥è¯¢å®Œæˆ:`, results);
                        } catch (error) {
                            console.error(`âŒ æ ¹æ® ID æŸ¥è¯¢å¤±è´¥:`, error.message);
                        }
                    }
                });

                document.getElementById('testSpecificRelayForPubkey').addEventListener('click', async () => {
                    const relayUrl = prompt('è¯·è¾“å…¥è¦æµ‹è¯•çš„ä¸­ç»§ URL:', 'wss://nostr.internal.ikandev.xyz');
                    const pubkey = prompt('è¯·è¾“å…¥è¦æµ‹è¯•çš„å…¬é’¥ (hex æ ¼å¼):', '98496f39197bb0da9b8d647560e3d1a96513a3642a3653836543525a56b8f2b8');
                    if (relayUrl && pubkey) {
                        await this.client.testSpecificRelayForPubkey(relayUrl, pubkey);
                    }
                });

                document.getElementById('testRawWebSocket').addEventListener('click', async () => {
                    const relayUrl = prompt('è¯·è¾“å…¥è¦æµ‹è¯•çš„ä¸­ç»§ URL:', 'wss://nostr.internal.ikandev.xyz');
                    const pubkey = prompt('è¯·è¾“å…¥è¦æµ‹è¯•çš„å…¬é’¥ (hex æ ¼å¼):', '98496f39197bb0da9b8d647560e3d1a96513a3642a3653836543525a56b8f2b8');
                    if (relayUrl && pubkey) {
                        try {
                            const eventCount = await this.client.testWithRawWebSocket(relayUrl, pubkey);
                            console.log(`âœ… åŸç”Ÿ WebSocket æµ‹è¯•å®Œæˆï¼Œæ”¶åˆ° ${eventCount} ä¸ªäº‹ä»¶`);
                        } catch (error) {
                            console.error(`âŒ åŸç”Ÿ WebSocket æµ‹è¯•å¤±è´¥:`, error.message);
                        }
                    }
                });

                document.getElementById('testTimelineLogic').addEventListener('click', async () => {
                    const relayUrl = prompt('è¯·è¾“å…¥è¦æµ‹è¯•çš„ä¸­ç»§ URL:', 'wss://nostr.internal.ikandev.xyz');
                    if (relayUrl) {
                        try {
                            const result = await this.client.testTimelineQueryLogic(relayUrl);
                            console.log(`âœ… æ—¶é—´çº¿é€»è¾‘æµ‹è¯•å®Œæˆ:`, result);
                        } catch (error) {
                            console.error(`âŒ æ—¶é—´çº¿é€»è¾‘æµ‹è¯•å¤±è´¥:`, error.message);
                        }
                    }
                });

                // å¼€å‘è€…æ¨¡å¼åˆ‡æ¢
                document.getElementById('toggleDevMode').addEventListener('click', () => {
                    this.toggleDevMode();
                });

                // æ·»åŠ ä¸­ç»§
                document.getElementById('addRelay').addEventListener('click', async () => {
                    await this.handleAddRelay();
                });

                    // å¿«é€Ÿæ·»åŠ ä¸­ç»§æŒ‰é’®ä¼šåœ¨ updateQuickAddRelays ä¸­åŠ¨æ€ç»‘å®š

                // æ–‡ç« æ“ä½œ
                document.addEventListener('click', async (e) => {
                    if (e.target.classList.contains('like-btn')) {
                        await this.handleLikeArticle(e.target);
                    }
                    if (e.target.classList.contains('bookmark-btn')) {
                        await this.handleBookmarkArticle(e.target);
                    }
                    if (e.target.classList.contains('follow-btn')) {
                        await this.handleFollowAuthor(e.target);
                    }
                    if (e.target.classList.contains('comment-btn')) {
                        await this.handleCommentArticle(e.target);
                    }
                    if (e.target.classList.contains('show-json-btn')) {
                        const eventId = e.target.dataset.eventId;
                        this.showEventJson(eventId);
                    }
                    if (e.target.classList.contains('close-json-btn')) {
                        const eventId = e.target.dataset.eventId;
                        this.hideEventJson(eventId);
                    }
                    if (e.target.classList.contains('copy-json-btn')) {
                        const eventId = e.target.dataset.eventId;
                        this.copyEventJson(eventId);
                    }
                });

                // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('json-modal')) {
                        const eventId = e.target.id.replace('json-modal-', '');
                        this.hideEventJson(eventId);
                    }
                });

                    // å¯†é’¥ç®¡ç†åŠŸèƒ½
                    this.bindKeyManagementEvents();
                }

                bindKeyManagementEvents() {
                    // æ ¼å¼åˆ‡æ¢
                    document.addEventListener('click', (e) => {
                        if (e.target.classList.contains('format-btn')) {
                            this.switchKeyFormat(e.target.dataset.format);
                        }
                    });

                    // å¤åˆ¶å…¬é’¥
                    document.getElementById('copy-public-key').addEventListener('click', () => {
                        this.copyToClipboard('public-key-display', 'copy-public-key');
                    });

                    // å¤åˆ¶ç§é’¥
                    document.getElementById('copy-private-key').addEventListener('click', () => {
                        this.copyToClipboard('private-key-display', 'copy-private-key');
                    });

                    // åˆ‡æ¢ç§é’¥æ˜¾ç¤º
                    document.getElementById('toggle-private-key').addEventListener('click', () => {
                        this.togglePrivateKeyVisibility();
                });
            }

            switchTab(tabType) {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.classList.remove('active');
                    if (tab.dataset.tab === tabType) {
                        tab.classList.add('active');
                    }
                });

                const contents = document.querySelectorAll('.tab-content');
                contents.forEach(content => {
                    content.classList.remove('active');
                });

                const activeContent = document.getElementById(tabType + '-tab');
                if (activeContent) {
                    activeContent.classList.add('active');
                }
            }

            showSection(sectionName) {
                const sections = ['auth-section', 'main-section'];
                sections.forEach(section => {
                    const element = document.getElementById(section);
                    if (element) {
                        element.style.display = 'none';
                    }
                });

                const activeSection = document.getElementById(sectionName + '-section');
                if (activeSection) {
                    activeSection.style.display = 'block';
                }

                this.currentSection = sectionName;
            }

            showUserInfo(user) {
                document.getElementById('user-name').textContent = user.name || 'æœªè®¾ç½®';
                document.getElementById('user-pubkey').textContent = user.npub;
                document.getElementById('user-about').textContent = user.about || 'æœªè®¾ç½®';

                    // æ›´æ–°å¯†é’¥æ˜¾ç¤º
                    this.updateKeyDisplay();
            }

            async handleCreateAccount() {
                try {
                    this.showStatus('åˆ›å»ºè´¦å·ä¸­...', 'info');

                    const name = document.getElementById('userName').value;
                    const about = document.getElementById('userAbout').value;

                    const user = await this.client.createAccount(name, about);

                    localStorage.setItem('nostr-user', JSON.stringify(user));

                    this.showStatus('è´¦å·åˆ›å»ºæˆåŠŸï¼', 'success');
                    this.showUserInfo(user);
                    this.showSection('main');

                } catch (error) {
                    this.showStatus('åˆ›å»ºè´¦å·å¤±è´¥: ' + error.message, 'error');
                }
            }

            async handleImportAccount() {
                try {
                    this.showStatus('å¯¼å…¥è´¦å·ä¸­...', 'info');

                    const nsec = document.getElementById('nsecInput').value;
                    const user = await this.client.importAccount(nsec);

                    localStorage.setItem('nostr-user', JSON.stringify(user));

                    this.showStatus('è´¦å·å¯¼å…¥æˆåŠŸï¼', 'success');
                    this.showUserInfo(user);
                    this.showSection('main');

                } catch (error) {
                    this.showStatus('å¯¼å…¥è´¦å·å¤±è´¥: ' + error.message, 'error');
                }
            }

            async handlePublishArticle() {
                try {
                    this.showStatus('å‘å¸ƒæ–‡ç« ä¸­...', 'info');

                    const title = document.getElementById('articleTitle').value;
                    const content = document.getElementById('articleContent').value;

                    if (!title || !content) {
                        this.showStatus('è¯·å¡«å†™æ–‡ç« æ ‡é¢˜å’Œå†…å®¹', 'error');
                        return;
                    }

                                            const result = await this.client.publishArticle(title, content);

                    if (result.success) {
                        this.showStatus(`æ–‡ç« å‘å¸ƒæˆåŠŸï¼å·²å‘é€åˆ° ${result.relayCount}/${this.client.relays.length} ä¸ªä¸­ç»§`, 'success');
                    } else {
                        this.showStatus(`æ–‡ç« å‘å¸ƒå¤±è´¥: ${result.error}`, 'error');
                    }

                    // æ¸…ç©ºè¡¨å•
                    document.getElementById('articleTitle').value = '';
                    document.getElementById('articleContent').value = '';

                    // æ·»åŠ åˆ°æœ¬åœ°åˆ—è¡¨
                        this.articles.unshift(result.event);
                    this.updateTimeline();

                } catch (error) {
                    this.showStatus('å‘å¸ƒæ–‡ç« å¤±è´¥: ' + error.message, 'error');
                }
            }

            async handleRefreshTimeline() {
                    try {
                        const timelineType = document.getElementById('timelineType').value;
                        this.showStatus(`æ­£åœ¨è·å–${this.getTimelineTypeName(timelineType)}...`, 'info');

                        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                        const timelineContent = document.getElementById('timeline-content');
                        timelineContent.innerHTML = `
                            <div class="loading">
                                <div>æ­£åœ¨ä»å¤šä¸ªä¸­ç»§è·å–æ•°æ®ï¼Œè¯·ç¨å€™...</div>
                                <div style="margin-top: 10px; font-size: 14px; color: #666;">
                                    æ—¶é—´çº¿ç±»å‹: ${this.getTimelineTypeName(timelineType)}<br>
                                    å½“å‰è¿æ¥çš„ä¸­ç»§: ${this.client.relays.join(', ')}
                                </div>
                            </div>
                        `;

                        let timeline;
                        switch (timelineType) {
                            case 'global':
                                timeline = await this.client.getTimeline(50);
                                break;
                            case 'followed':
                                timeline = await this.client.getFollowedTimeline(50);
                                break;
                            case 'user':
                                if (!this.client.publicKey) {
                                    throw new Error('è¯·å…ˆç™»å½•');
                                }
                                timeline = await this.client.getUserTimeline(this.client.publicKey, 50);
                                break;
                            default:
                                timeline = await this.client.getTimeline(50);
                        }

                        this.articles = timeline;
                this.updateTimeline();

                        if (timeline.length === 0) {
                            this.showStatus(`æœªæ‰¾åˆ°ä»»ä½•æ–‡ç« `, 'info');
                            timelineContent.innerHTML = `
                                <div class="status info">
                                    <strong>æœªæ‰¾åˆ°æ–‡ç« </strong><br>
                                    æ—¶é—´çº¿ç±»å‹: ${this.getTimelineTypeName(timelineType)}<br>
                                    å¯èƒ½çš„åŸå› ï¼š<br>
                                    â€¢ å½“å‰ä¸­ç»§ä¸­æ²¡æœ‰ç›¸å…³å†…å®¹<br>
                                    â€¢ éœ€è¦æ·»åŠ æ›´å¤šä¸­ç»§<br>
                                    â€¢ ç½‘ç»œè¿æ¥é—®é¢˜<br>
                                    <br>
                                    <button onclick="app.handleRefreshTimeline()" style="background: #667eea; margin-top: 10px;">
                                        é‡è¯•è·å–
                                    </button>
                                </div>
                            `;
                        } else {
                            this.showStatus(`${this.getTimelineTypeName(timelineType)}å·²æ›´æ–°ï¼è·å–åˆ° ${timeline.length} ç¯‡æ–‡ç« `, 'success');
                        }
                    } catch (error) {
                        console.error('åˆ·æ–°æ—¶é—´çº¿å¤±è´¥:', error);
                        this.showStatus('åˆ·æ–°æ—¶é—´çº¿å¤±è´¥: ' + error.message, 'error');

                        // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
                        const timelineContent = document.getElementById('timeline-content');
                        timelineContent.innerHTML = `
                            <div class="status error">
                                <strong>è·å–æ—¶é—´çº¿å¤±è´¥</strong><br>
                                é”™è¯¯ä¿¡æ¯: ${error.message}<br>
                                è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•<br>
                                <br>
                                <button onclick="app.handleRefreshTimeline()" style="background: #667eea; margin-top: 10px;">
                                    é‡è¯•è·å–
                                </button>
                            </div>
                        `;
                    }
                }

                getTimelineTypeName(type) {
                    switch (type) {
                        case 'global': return 'å…¨å±€æ—¶é—´çº¿';
                        case 'followed': return 'å…³æ³¨ç”¨æˆ·æ—¶é—´çº¿';
                        case 'user': return 'æˆ‘çš„æ–‡ç« ';
                        default: return 'æ—¶é—´çº¿';
                    }
            }

            async handleAddRelay() {
                try {
                    const relayUrl = document.getElementById('relayUrl').value;

                    if (!relayUrl) {
                        this.showStatus('è¯·è¾“å…¥ä¸­ç»§åœ°å€', 'error');
                        return;
                    }

                    this.showStatus('è¿æ¥ä¸­ç»§ä¸­...', 'info');

                    await this.client.addRelay(relayUrl);

                    this.showStatus('ä¸­ç»§è¿æ¥æˆåŠŸï¼', 'success');
                    this.updateRelayList();
                        this.updateQuickAddRelays(); // æ›´æ–°å¿«é€Ÿæ·»åŠ åˆ—è¡¨

                    document.getElementById('relayUrl').value = '';

                } catch (error) {
                    this.showStatus('è¿æ¥ä¸­ç»§å¤±è´¥: ' + error.message, 'error');
                }
            }

                async handleQuickAddRelay(relayUrl) {
                    try {
                        this.showStatus(`æ­£åœ¨æ·»åŠ ä¸­ç»§: ${relayUrl}`, 'info');

                        await this.client.addRelay(relayUrl);

                        this.showStatus('ä¸­ç»§æ·»åŠ æˆåŠŸï¼', 'success');
                        this.updateRelayList();
                        this.updateQuickAddRelays(); // æ›´æ–°å¿«é€Ÿæ·»åŠ åˆ—è¡¨

                    } catch (error) {
                        this.showStatus('æ·»åŠ ä¸­ç»§å¤±è´¥: ' + error.message, 'error');
                    }
                }

                                async handleRemoveRelay(relayUrl) {
                    try {
                        if (confirm(`ç¡®å®šè¦ç§»é™¤ä¸­ç»§ ${relayUrl} å—ï¼Ÿ`)) {
                            const success = this.client.removeRelay(relayUrl);

                            if (success) {
                                this.showStatus('ä¸­ç»§ç§»é™¤æˆåŠŸï¼', 'success');
                                this.updateRelayList();
                                this.updateQuickAddRelays(); // æ›´æ–°å¿«é€Ÿæ·»åŠ åˆ—è¡¨
                            } else {
                                this.showStatus('ç§»é™¤ä¸­ç»§å¤±è´¥', 'error');
                            }
                        }
                    } catch (error) {
                        this.showStatus('ç§»é™¤ä¸­ç»§å¤±è´¥: ' + error.message, 'error');
                    }
                }

                async handleDebugRelays() {
                    try {
                        this.showStatus('æ­£åœ¨æµ‹è¯•æ‰€æœ‰ä¸­ç»§è¿æ¥...', 'info');

                        const timelineContent = document.getElementById('timeline-content');
                        timelineContent.innerHTML = '<div class="loading">æ­£åœ¨æµ‹è¯•ä¸­ç»§è¿æ¥...</div>';

                        const results = [];

                        for (const relay of this.client.relays) {
                            try {
                                console.log(`æµ‹è¯•ä¸­ç»§: ${relay}`);

                                // æµ‹è¯•è¿æ¥
                                await this.client.testRelayConnection(relay);

                                // å°è¯•æŸ¥è¯¢æ•°æ®
                                const events = await this.client.pool.querySync([relay], [
                                    {
                                        kinds: [this.client.eventKinds.LONG_FORM],
                                        limit: 5
                                    }
                                ], {
                                    timeout: 5000
                                });

                                results.push({
                                    relay,
                                    status: 'success',
                                    events: events.length,
                                    message: `âœ… è¿æ¥æˆåŠŸï¼Œæ‰¾åˆ° ${events.length} ä¸ªäº‹ä»¶`
                                });

                            } catch (error) {
                                results.push({
                                    relay,
                                    status: 'error',
                                    events: 0,
                                    message: `âŒ è¿æ¥å¤±è´¥: ${error.message}`
                                });
                            }
                        }

                        // æ˜¾ç¤ºç»“æœ
                        let html = '<div style="background: #f8f9fa; padding: 15px; border-radius: 6px;">';
                        html += '<h3>ä¸­ç»§è¿æ¥æµ‹è¯•ç»“æœ</h3>';

                        results.forEach(result => {
                            const color = result.status === 'success' ? '#28a745' : '#dc3545';
                            html += `
                                <div style="margin: 10px 0; padding: 10px; border-left: 4px solid ${color}; background: white;">
                                    <strong>${result.relay}</strong><br>
                                    <span style="color: ${color};">${result.message}</span>
                                </div>
                            `;
                        });

                        html += '</div>';
                        timelineContent.innerHTML = html;

                        const successCount = results.filter(r => r.status === 'success').length;
                        this.showStatus(`æµ‹è¯•å®Œæˆ: ${successCount}/${this.client.relays.length} ä¸ªä¸­ç»§è¿æ¥æˆåŠŸ`, 'success');

                    } catch (error) {
                        console.error('è°ƒè¯•ä¸­ç»§å¤±è´¥:', error);
                        this.showStatus('è°ƒè¯•ä¸­ç»§å¤±è´¥: ' + error.message, 'error');
                }
            }

            async handleLikeArticle(button) {
                try {
                    const articleId = button.dataset.articleId;
                    const authorPubkey = button.dataset.authorPubkey;

                    await this.client.likeArticle(articleId, authorPubkey);

                    button.classList.add('active');
                    button.textContent = 'å·²ç‚¹èµ';

                    this.showStatus('ç‚¹èµæˆåŠŸï¼', 'success');

                } catch (error) {
                    this.showStatus('ç‚¹èµå¤±è´¥: ' + error.message, 'error');
                }
            }

            async handleBookmarkArticle(button) {
                try {
                    const articleId = button.dataset.articleId;
                    const title = button.dataset.title;

                    await this.client.bookmarkArticle(articleId, title);

                    button.classList.add('active');
                    button.textContent = 'å·²æ”¶è—';

                    this.showStatus('æ”¶è—æˆåŠŸï¼', 'success');

                } catch (error) {
                    this.showStatus('æ”¶è—å¤±è´¥: ' + error.message, 'error');
                }
            }

            async handleFollowAuthor(button) {
                try {
                    const authorPubkey = button.dataset.authorPubkey;
                    const authorName = button.dataset.authorName;

                    await this.client.followAuthor(authorPubkey, authorName);

                    button.classList.add('active');
                    button.textContent = 'å·²å…³æ³¨';

                    this.showStatus('å…³æ³¨æˆåŠŸï¼', 'success');

                } catch (error) {
                    this.showStatus('å…³æ³¨å¤±è´¥: ' + error.message, 'error');
                }
            }

            async handleCommentArticle(button) {
                try {
                    const articleId = button.dataset.articleId;
                    const authorPubkey = button.dataset.authorPubkey;

                    const content = prompt('è¯·è¾“å…¥è¯„è®ºå†…å®¹:');
                    if (!content) return;

                    await this.client.commentOnArticle(articleId, authorPubkey, content);

                    this.showStatus('è¯„è®ºå‘å¸ƒæˆåŠŸï¼', 'success');

                } catch (error) {
                    this.showStatus('å‘å¸ƒè¯„è®ºå¤±è´¥: ' + error.message, 'error');
                }
            }

            updateTimeline() {
                const timelineContent = document.getElementById('timeline-content');

                if (this.articles.length === 0) {
                    timelineContent.innerHTML = '<div class="status info">æš‚æ— æ–‡ç« ï¼Œè¯·å‘å¸ƒæ–‡ç« æˆ–è¿æ¥åˆ°æ›´å¤šä¸­ç»§</div>';
                    return;
                }

                let html = '';
                    this.articles.forEach(event => {
                        const timeStr = this.client.formatTime(event.created_at);
                        let title = '';
                        let content = event.content;
                        let eventType = '';

                        // æ ¹æ®äº‹ä»¶ç±»å‹å¤„ç†æ˜¾ç¤º
                        switch (event.kind) {
                            case 0: // å…ƒæ•°æ®
                                eventType = 'ğŸ“ ç”¨æˆ·èµ„æ–™';
                                try {
                                    const metadata = JSON.parse(event.content);
                                    title = metadata.name || 'ç”¨æˆ·èµ„æ–™';
                                    content = `æ˜µç§°: ${metadata.name || 'æœªè®¾ç½®'}\nç®€ä»‹: ${metadata.about || 'æœªè®¾ç½®'}\nç½‘ç«™: ${metadata.website || 'æœªè®¾ç½®'}`;
                                } catch (e) {
                                    title = 'ç”¨æˆ·èµ„æ–™';
                                    content = event.content;
                                }
                                break;
                            case 1: // æ–‡æœ¬ç¬”è®°
                                eventType = 'ğŸ’¬ çŸ­æ¶ˆæ¯';
                                title = 'çŸ­æ¶ˆæ¯';
                                break;
                            case 30023: // é•¿æ–‡
                                eventType = 'ğŸ“„ æ–‡ç« ';
                                title = this.client.getTagValue(event.tags, 'title') || 'æ— æ ‡é¢˜';
                                break;
                            case 1111: // è¯„è®º
                                eventType = 'ğŸ’­ è¯„è®º';
                                title = 'è¯„è®º';
                                break;
                            default:
                                eventType = `ğŸ”§ äº‹ä»¶ç±»å‹ ${event.kind}`;
                                title = `äº‹ä»¶ç±»å‹ ${event.kind}`;
                        }

                    html += `
                        <div class="article-item">
                            <div class="article-title">${eventType} - ${this.escapeHtml(title)}</div>
                            <div class="article-content">${this.escapeHtml(content.substring(0, 200))}${content.length > 200 ? '...' : ''}</div>
                            <div class="article-meta">
                                ä½œè€…: ${this.client.truncateKey(event.pubkey)} |
                                å‘å¸ƒæ—¶é—´: ${timeStr} |
                                äº‹ä»¶ç±»å‹: ${event.kind}
                            </div>
                            <div class="article-actions">
                                <button class="like-btn" data-article-id="${event.id}" data-author-pubkey="${event.pubkey}">
                                    ğŸ‘ ç‚¹èµ
                                </button>
                                <button class="bookmark-btn" data-article-id="${event.id}" data-title="${this.escapeHtml(title)}">
                                    ğŸ“š æ”¶è—
                                </button>
                                <button class="follow-btn" data-author-pubkey="${event.pubkey}" data-author-name="${this.client.truncateKey(event.pubkey)}">
                                    ğŸ‘¥ å…³æ³¨
                                </button>
                                <button class="comment-btn" data-article-id="${event.id}" data-author-pubkey="${event.pubkey}">
                                    ğŸ’¬ è¯„è®º
                                </button>
                                <button class="show-json-btn" data-event-id="${event.id}" style="background: #6c757d; margin-left: 5px;">
                                    ğŸ“‹ JSON
                                </button>
                            </div>
                            <div id="json-modal-${event.id}" class="json-modal" style="display: none;">
                                <div class="json-modal-content">
                                    <div class="json-modal-header">
                                        <h3>äº‹ä»¶å®Œæ•´ JSON</h3>
                                        <button class="close-json-btn" data-event-id="${event.id}">&times;</button>
                                    </div>
                                    <div class="json-modal-body">
                                        <textarea id="json-content-${event.id}" readonly style="width: 100%; height: 400px; font-family: monospace; font-size: 12px; background: #f8f9fa; border: 1px solid #ddd; padding: 10px;">${JSON.stringify(event, null, 2)}</textarea>
                                    </div>
                                    <div class="json-modal-footer">
                                        <button class="copy-json-btn" data-event-id="${event.id}" style="background: #28a745;">å¤åˆ¶ JSON</button>
                                        <button class="close-json-btn" data-event-id="${event.id}" style="background: #6c757d;">å…³é—­</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });

                timelineContent.innerHTML = html;
            }

            updateRelayList() {
                const relayItems = document.getElementById('relay-items');
                const relays = this.client.getRelays();

                let html = '';
                relays.forEach(relay => {
                    html += `
                        <div class="relay-item">
                            <div>
                                <span class="relay-status ${relay.connected ? 'connected' : 'disconnected'}"></span>
                                ${relay.url}
                            </div>
                                <div>
                                    ${relay.connected ? 'å·²è¿æ¥' : 'æœªè¿æ¥'}
                                    <button class="remove-relay-btn" data-relay="${relay.url}" style="background: #dc3545; margin-left: 10px; padding: 4px 8px; font-size: 12px;">
                                        âŒ ç§»é™¤
                                    </button>
                                </div>
                        </div>
                    `;
                });

                relayItems.innerHTML = html;

                    // ç»‘å®šç§»é™¤æŒ‰é’®äº‹ä»¶
                    document.querySelectorAll('.remove-relay-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const relayUrl = e.target.dataset.relay;
                            this.handleRemoveRelay(relayUrl);
                        });
                    });
                }

                updateQuickAddRelays() {
                    const quickAddContainer = document.getElementById('quick-add-relays');
                    const recommendedRelays = this.client.getRecommendedRelays();

                    if (recommendedRelays.length === 0) {
                        quickAddContainer.innerHTML = '<p style="color: #666;">æ‰€æœ‰æ¨èä¸­ç»§å·²æ·»åŠ </p>';
                        return;
                    }

                    let html = '';
                    recommendedRelays.forEach(relay => {
                        html += `
                            <button class="quick-add-relay-btn" data-relay="${relay.url}" style="background: #17a2b8; margin: 5px; padding: 8px 12px; font-size: 14px;">
                                æ·»åŠ  ${relay.name}
                            </button>
                        `;
                    });

                    quickAddContainer.innerHTML = html;

                    // ç»‘å®šå¿«é€Ÿæ·»åŠ æŒ‰é’®äº‹ä»¶
                    document.querySelectorAll('.quick-add-relay-btn').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            const relayUrl = e.target.dataset.relay;
                            await this.handleQuickAddRelay(relayUrl);
                        });
                    });
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            showStatus(message, type) {
                const statusDiv = document.getElementById('status-message');
                statusDiv.className = `status ${type}`;
                statusDiv.textContent = message;
                statusDiv.style.display = 'block';

                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }

            // æ˜¾ç¤ºäº‹ä»¶ JSON
            showEventJson(eventId) {
                const modal = document.getElementById(`json-modal-${eventId}`);
                if (modal) {
                    modal.style.display = 'flex';
                }
            }

            // éšè—äº‹ä»¶ JSON
            hideEventJson(eventId) {
                const modal = document.getElementById(`json-modal-${eventId}`);
                if (modal) {
                    modal.style.display = 'none';
                }
            }

                        // å¤åˆ¶ JSON å†…å®¹
            copyEventJson(eventId) {
                const textarea = document.getElementById(`json-content-${eventId}`);
                if (textarea) {
                    textarea.select();
                    textarea.setSelectionRange(0, 99999); // å…¼å®¹ç§»åŠ¨ç«¯

                    try {
                        document.execCommand('copy');
                        this.showStatus('JSON å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
                    } catch (err) {
                        this.showStatus('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
                    }
                }
            }

            // åˆ‡æ¢å¼€å‘è€…æ¨¡å¼
            toggleDevMode() {
                const app = document.getElementById('app');
                const isDevMode = app.classList.contains('dev-mode');

                if (isDevMode) {
                    app.classList.remove('dev-mode');
                    this.showStatus('å¼€å‘è€…æ¨¡å¼å·²å…³é—­', 'info');
                } else {
                    app.classList.add('dev-mode');
                    this.showStatus('å¼€å‘è€…æ¨¡å¼å·²å¼€å¯', 'success');
                }
            }

                // å¯†é’¥ç®¡ç†ç›¸å…³æ–¹æ³•
                switchKeyFormat(format) {
                    const formatBtns = document.querySelectorAll('.format-btn');
                    formatBtns.forEach(btn => btn.classList.remove('active'));

                    const activeBtn = document.querySelector(`[data-format="${format}"]`);
                    if (activeBtn) {
                        activeBtn.classList.add('active');
                    }

                    const publicKeyDisplay = document.getElementById('public-key-display');
                    if (!this.client.publicKey) return;

                    if (format === 'npub') {
                        const npub = nip19.npubEncode(this.client.publicKey);
                        publicKeyDisplay.value = npub;
                    } else {
                        publicKeyDisplay.value = this.client.publicKey;
                    }
                }

                copyToClipboard(elementId, buttonId) {
                    const element = document.getElementById(elementId);
                    const button = document.getElementById(buttonId);

                    if (!element || !element.value) {
                        this.showStatus('æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹', 'error');
                        return;
                    }

                    // åˆ›å»ºä¸´æ—¶è¾“å…¥æ¡†æ¥å¤åˆ¶æ–‡æœ¬
                    const tempInput = document.createElement('input');
                    tempInput.value = element.value;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    tempInput.setSelectionRange(0, 99999); // å…¼å®¹ç§»åŠ¨ç«¯

                    try {
                        document.execCommand('copy');
                        this.showStatus('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');

                        // æŒ‰é’®åé¦ˆæ•ˆæœ
                        const originalText = button.textContent;
                        button.textContent = 'âœ… å·²å¤åˆ¶';
                        button.classList.add('copy-success');

                        setTimeout(() => {
                            button.textContent = originalText;
                            button.classList.remove('copy-success');
                        }, 2000);

                    } catch (err) {
                        this.showStatus('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶', 'error');
                    } finally {
                        document.body.removeChild(tempInput);
                    }
                }

                togglePrivateKeyVisibility() {
                    const privateKeyInput = document.getElementById('private-key-display');
                    const toggleBtn = document.getElementById('toggle-private-key');

                    if (privateKeyInput.type === 'password') {
                        privateKeyInput.type = 'text';
                        toggleBtn.textContent = 'ğŸ™ˆ éšè—';
                        toggleBtn.style.background = '#dc3545';
                    } else {
                        privateKeyInput.type = 'password';
                        toggleBtn.textContent = 'ğŸ‘ï¸ æ˜¾ç¤º';
                        toggleBtn.style.background = '#6c757d';
                    }
                }

                updateKeyDisplay() {
                    if (!this.client.publicKey) return;

                    const publicKeyDisplay = document.getElementById('public-key-display');
                    const privateKeyDisplay = document.getElementById('private-key-display');

                    // è·å–å½“å‰é€‰ä¸­çš„æ ¼å¼
                    const activeFormatBtn = document.querySelector('.format-btn.active');
                    const format = activeFormatBtn ? activeFormatBtn.dataset.format : 'npub';

                    // æ˜¾ç¤ºå…¬é’¥
                    if (format === 'npub') {
                        const npub = nip19.npubEncode(this.client.publicKey);
                        publicKeyDisplay.value = npub;
                    } else {
                        publicKeyDisplay.value = this.client.publicKey;
                    }

                    // æ˜¾ç¤ºç§é’¥ (nsec æ ¼å¼)
                    const savedUser = localStorage.getItem('nostr-user');
                    if (savedUser) {
                        const user = JSON.parse(savedUser);
                        if (user.nsec) {
                            privateKeyDisplay.value = user.nsec;
                        }
                    }
            }
        }

        // å¯åŠ¨åº”ç”¨
        const app = new NostrApp();
        app.init();
        });
    </script>
</body>
</html>
